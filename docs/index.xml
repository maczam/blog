<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Blog</title>
    <link>https://www.hexin.me/</link>
    <description>Recent content on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Jul 2019 13:51:05 +0800</lastBuildDate>
    
        <atom:link href="https://www.hexin.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Raft 为什么是更易理解的分布式一致性算法</title>
      <link>https://www.hexin.me/post/2019/07/why-raft-easier-to-understand/</link>
      <pubDate>Fri, 26 Jul 2019 13:51:05 +0800</pubDate>
      
      <guid>https://www.hexin.me/post/2019/07/why-raft-easier-to-understand/</guid>
      
        <description>最近在研究一致性算法这块，发现一篇很好的文章，但是作者对算法冷启动描述不太详细，后面我会补上这块。etcd是raft的一个实现，我后面会出一个专辑，专门解读etcd的源码阅读，帮助自己加深理解。后面还有有zookeeper以及paxos系列。下面我们就开始阅读。
一致性问题可以算是分布式领域的一个圣殿级问题了，关于它的研究可以回溯到几十年前。
#拜占庭将军问题 Leslie Lamport 在三十多年前发表的论文《拜占庭将军问题》（参考[1]）。
拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。在战争的时候，拜占庭军队内所有将军必需达成 一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序，在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员不可靠的情况下，其余忠诚的将军在不受叛徒或间谍的影响下如何达成一致的协议，拜占庭问题就此形成。拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。
Lamport 一直研究这类问题，发表了一系列论文。但综合总结一下就是回答下面三个问题：
 类似拜占庭将军这样的分布式一致性问题是否有解？ 如果有解的话需要满足什么样的条件？ 在特定前提条件的基础上，提出一种解法。  前两个问题 Lamport 在论文《拜占庭将军问题》已经回答，而第三个问题在后来的论文 《The Part-Time Parliament》中提出了一种算法并命名为 Paxos。这篇论文使用了大量的数学证明，而我基本就看不懂了（数学符号都认不全-｡-;），考虑到大家理解起来都比较困难，后来 Lamport 又写了另外一篇论文 《Paxos Made Simple》完全放弃了所有数学符号的证明，使用纯英文的逻辑推导。我勉强逐字看了一遍，然后感觉若有所悟，但你问我搞懂了吗，我的标准应该还是没懂。对我来说理解一个算法有个明确的标准，就是真的懂了会在头脑里能将算法映射为代码，而看完后面一篇论文仅仅是若有所悟还达不到能映射为代码的清晰度。
虽然 Lamport 认为 Paxos 很 simple，但也许只是针对他的头脑而言。事实是大家理解起来都还是很困难，所以 Raft 就是建立在希望得到一个更易于理解的 Paxos 算法的替代品。把可理解性作为算法的主要目标之一，从论文题目就可看出来《In Search of an Understandable Consensus Algorithm》。
在进入正题前，我想起一个旧故事可以很直观的感受对一个问题不同的思维视角在可理解性上的差异。
#不同视角的可理解性
依稀记得大约在二十年前，我还在读初中时在一本可能大概叫《数学中的发散思维》（不能很清晰记得书名了）的书中看到这么一个有趣的问题。
 甲乙两人轮流在一张圆桌上平放黑白围棋子，每次放一子，棋子不许重叠，谁先没有地方放就输。 请问怎样放才能赢？
 这个问题有两层意思，第一，有没有一种放法保证必赢？第二，如果有怎么证明？这里先停顿下，思考十秒钟。
上面的图回答了这个问题，就是先行者必胜，这里使用了三种不同的思维方式。
 假如桌子只有一个围棋子那么大。 假如桌子无限大，先行者先占住圆心，由于圆是对称图形，所以只要对手还能找到位置放，你总能在对称的另一面找到位置放。 一个圆中可画单数个直径相等且互切的小圆。  三种不同的思维方式在可理解性难度上逐渐加深。第一种是极简化思维，但数学上是不严谨的。第二种是极限思维，和第一种结合起来就是数学归纳法了，在数学上是严谨的。第三种是形象思维，使用了几何学概念，但对于没有几何学基础知识的人就很难理解了。
#Raft 协议的易理解性描述
虽然 Raft 的论文比 Paxos 简单版论文还容易读了，但论文依然发散的比较多，相对冗长。读完后掩卷沉思觉得还是整理一下才会更牢靠，变成真正属于自己的。这里我就借助前面黑白棋落子里第一种极简思维来描述和概念验证下 Raft 协议的工作方式。
在一个由 Raft 协议组织的集群中有三类角色：</description>
      
    </item>
    
    <item>
      <title>Hugo搭建Github静态Blog</title>
      <link>https://www.hexin.me/post/2019/07/make-blog/</link>
      <pubDate>Thu, 25 Jul 2019 16:45:53 +0800</pubDate>
      
      <guid>https://www.hexin.me/post/2019/07/make-blog/</guid>
      
        <description>一直都有搭建blog的想法，最近研究了静态博客系统。主要想法是依赖于github，其中有两个github pages和github issues思路。
那问题了来了，什么是github pages？ github pages是github提供一个在线服务，可以将github仓库里面的静态资源（html、markdwon）渲染成也页面，帮你生成一个二级域名，甚至可以绑定自己域名。所以使用pages的人最多。为什么有些框架可以使用github的issues能构建出漂亮的静态站点，甚至动态的呢？框架拉取你的issues信息，并转化成html保存到github上，然后在使用pages服务，具体如何使用，这里有介绍https://www.v2ex.com/amp/t/566714。更有一些激进的人直接issues系统，只做一些记录。我最终的选择直接pages服务来搭建，
大方向选定以后，开始选中框架，我喜欢一些从简，所以我选择hugo，编写工具使用Typora，图床使用阿里的oss，毕竟国内访问的多。 下面就开始我的搭建之路。
具体安装过程，参考https://www.gohugo.org，下面我只说我才过的一些坑，和我的系统构架。
git仓库构建 仓库目录结构 drwxr-xr-x 15 hexin staff 480B 7 25 14:13 . drwxr-xr-x 18 hexin staff 576B 7 25 13:21 .. drwxr-xr-x 14 hexin staff 448B 7 25 16:28 .git -rw-r--r-- 1 hexin staff 100B 7 25 13:43 .gitmodules -rw-r--r-- 1 hexin staff 0B 7 25 14:13 .nojekyll drwxr-xr-x 3 hexin staff 96B 7 25 14:02 archetypes -rw-r--r-- 1 hexin staff 615B 7 25 14:01 config.</description>
      
    </item>
    
    <item>
      <title>Test</title>
      <link>https://www.hexin.me/post/2019/07/test/</link>
      <pubDate>Thu, 25 Jul 2019 13:51:05 +0800</pubDate>
      
      <guid>https://www.hexin.me/post/2019/07/test/</guid>
      
        <description> 第一篇blog测试 我是测试内容
 2019年测试
 </description>
      
    </item>
    
  </channel>
</rss>
